? Based on the information provided in the prompt (file structure, go.mod, and README.md), I have sufficient context to generate the .opsee configuration file. Let me produce the output
: null
architecture:
    data_flow: "User input via CLI args -> Cobra command parsing -> \nAI provider API call -> Response formatting -> Terminal output\n"
    key_files:
        - path: cmd/
          role: Main entry point and cobra command definitions
        - path: internal/
          role: Core business logic, AI provider integrations, context gathering
        - path: pkg/
          role: Reusable utilities that could be imported by other projects
    pattern: standard go project layout (cmd/internal/pkg)
codebase_map:
    directories:
        cmd:
            entry: cmd/main.go or cmd/how/main.go
            path: cmd/
            purpose: CLI entry points and command definitions
        internal:
            path: internal/
            purpose: Private application code not importable by other projects
        pkg:
            path: pkg/
            purpose: Public library code that can be imported by external projects
        scripts:
            path: scripts/
            purpose: Build and installation scripts
commands:
    build: make build
    dev: make dev
    install: make install
    setup_dev: make setup-dev
    test: make test
common_tasks:
    add_ai_provider:
        - Implement provider interface in internal/
        - Add provider selection in config/setup
        - Update viper config structure
    add_command:
        - Create new file in cmd/ directory
        - Define cobra.Command with Use, Short, Long, Run
        - Register with parent command in init()
    add_feature:
        - Add business logic in internal/
        - Expose via cobra command in cmd/
        - Add configuration options via viper
conventions:
    file_organization: |
        cmd/how/main.go - CLI entry point
        internal/provider/ - AI provider implementations
        internal/context/ - Shell context gathering
        pkg/ - Reusable, exportable utilities
    naming:
        constants: CamelCase for exported, camelCase for private
        files: lowercase with underscores (go standard)
        functions: CamelCase for exported, camelCase for private
        packages: lowercase, short, no underscores
    patterns:
        - Follow standard Go project layout with cmd/internal/pkg
        - Use cobra for all CLI commands with proper subcommand structure
        - Configuration via viper supporting YAML files and environment variables
        - Error handling with explicit error returns, no panic in library code
development:
    run: make dev && ./bin/how
    setup:
        - git clone https://github.com/Codilas/how.git
        - cd how
        - make setup-dev
project:
    description: AI shell assistant for commands, explanations, and code generation
    framework: cobra
    name: how
    primary_language: go
    type: cli
tech_stack:
    cache: none
    database: none
    framework: cobra for CLI framework
    key_libraries:
        - name: spf13/cobra
          purpose: CLI command structure and argument parsing
        - name: spf13/viper
          purpose: Configuration management with file and env support
        - name: AlecAivazis/survey/v2
          purpose: Interactive prompts for setup wizard
        - name: briandowns/spinner
          purpose: Terminal spinners for async operations
        - name: fatih/color
          purpose: Colored terminal output
        - name: gopkg.in/yaml.v3
          purpose: YAML config file parsing
    package_manager: go modules
    runtime: go 1.22.4
testing:
    framework: go test (standard library)
    location: '*_test.go files alongside source files'
    patterns:
        - Table-driven tests for multiple input scenarios
        - Test files in same package as source
    run: make test or go test ./...
